c++
对象是占有实际空间的，而类型并不实际占有存储空间
C++为输入输出流提供了一些格式控制功能：
    dec:指定数据使用十进制
    hex:十六进制
    oct:八进制
在C++允许对变量的声明放在程序的任何位置（声明在使用之前），这是C++对C限制的放宽

1、函数重载的解释与实例
2、函数模板
3、Ｃ＋＋允许函数有默认参数
4、变量的引用（别名）
    引用和指针的不同点
        引用在定义时必须初始化，指针没有要求
        引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
        没有NULL引用，但有NULL指针
        在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占 4个字节)
        引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
        有多级指针，但是没有多级引用
        访问实体方式不同，指针需要显式解引用，引用编译器自己处理
        引用比指针使用起来相对更安全
C++之所以增加引用，主要是利用它作为函数参数，以扩充函数传递数据的功能。
在C++中函数参数的传递有一下两种方法：
    （１）、将变量名作为实参
    （２）、传递变量的指针
    （３）、传送变量名的别名
取别名使得在函数传参的作用变得容易，而取别名也实际上相当于另外一个变量的地址使用。
5、内联函数
        宏定义是在编译前由预处理对其预处理的，只做简单的字符置换而不做语法检查，往往会出现意向不到的错误
        使用内置函数可以节省运行时间，但却增加了目标程序的长度。使用的方式不是调用而是内置，函数使用多少次就会内置多少次，因此只适用与规模下且使用频繁使用的函数。

6、作用域运算符
        闭包
        #include <iostream>
        using namespace std;
        float a  = 13.5;
        int main()
        {
            int a = 5;
            cout <<a ;
            cout << ::a;
            return 0;
        }
        使用::输出全局作用域的变量
7、字符串变量
        字符串变量和字符串常量

8、动态分配/销毁内存的运算符：new/delete
        new和delete的时运算符，malloc和free属于函数
        c语言中利用库函数malloc和free分配和撤销内存空间。但是使用malloc函数需要指定开辟的内存空间大小。其调用的形式malloc(size)，size是字节数，需要事先求出或用sizeof运算符由系统求出，此外malloc函数只能从用户处知道应开辟空间的大小而不知道数据的类型，因此无法使其返回的指针指向具体的数据。其值一律指向void*类型，需要在程序中进行强制的转换，才能使其返回的指针指向具体的数据。
        new int;
        new int[100];
        new char[10];
        float *p = new float(3.14);
        new 分配数组空间时不能指定初值。

C++对C的进一步的扩展与封装
        .函数支持默认参数
        .作用域形成的闭包技术
        .string的封装


